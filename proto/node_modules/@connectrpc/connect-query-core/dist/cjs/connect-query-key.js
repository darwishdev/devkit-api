"use strict";
// Copyright 2021-2023 The Connect Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConnectQueryKey = createConnectQueryKey;
const message_key_js_1 = require("./message-key.js");
const transport_key_js_1 = require("./transport-key.js");
/**
 * TanStack Query manages query caching for you based on query keys. In Connect Query, keys are structured, and can easily be created using this factory function.
 *
 * When you make a query, a unique key is automatically created from the schema, input message, and transport. For example:
 *
 * ```ts
 * import { useQuery } from "@connectrpc/connect-query";
 *
 * useQuery(ElizaService.method.say, { sentence: "hello" });
 *
 * // creates the key:
 * [
 *   "connect-query",
 *   {
 *     transport: "t1",
 *     serviceName: "connectrpc.eliza.v1.ElizaService",
 *     methodName: "Say",
 *     input: { sentence: "hello" },
 *     cardinality: "finite",
 *   }
 * ]
 * ```
 *
 * The same key can be created manually with this factory:
 *
 * ```ts
 * createConnectQueryKey({
 *   transport: myTransportReference,
 *   schema: ElizaService.method.say,
 *   input: { sentence: "hello" }
 * });
 * ```
 *
 * Note that the factory allows to create partial keys that can be used to filter queries. For example, you can create a key without a transport, any cardinality, any input message, or with a partial input message.
 *
 * @see ConnectQueryKey for information on the components of Connect-Query's keys.
 */
function createConnectQueryKey(params) {
    const props = params.schema.kind == "rpc"
        ? {
            serviceName: params.schema.parent.typeName,
            methodName: params.schema.name,
        }
        : {
            serviceName: params.schema.typeName,
        };
    if (params.transport !== undefined) {
        props.transport = (0, transport_key_js_1.createTransportKey)(params.transport);
    }
    if (params.cardinality !== undefined) {
        props.cardinality = params.cardinality;
    }
    if (params.schema.kind == "rpc" && "input" in params) {
        if (typeof params.input == "symbol") {
            props.input = "skipped";
        }
        else if (params.input !== undefined) {
            props.input = (0, message_key_js_1.createMessageKey)(params.schema.input, params.input, params.pageParamKey);
        }
    }
    return ["connect-query", props];
}
//# sourceMappingURL=connect-query-key.js.map