import type { DescMethod, DescService, MessageInitShape } from "@bufbuild/protobuf";
import type { Transport } from "@connectrpc/connect";
import type { SkipToken } from "@tanstack/query-core";
/**
 * TanStack Query manages query caching for you based on query keys. `QueryKey`s in TanStack Query are arrays with arbitrary JSON-serializable data - typically handwritten for each endpoint.
 *
 * In Connect Query, query keys are more structured, since queries are always tied to a service, RPC, input message, and transport. For example, for a query key might look like this:
 *
 * @example
 * [
 *   "connect-query",
 *   {
 *     transport: "t1",
 *     serviceName: "connectrpc.eliza.v1.ElizaService",
 *     methodName: "Say",
 *     input: {
 *       sentence: "hello there",
 *     },
 *     cardinality: "finite",
 *   }
 * ]
 */
export type ConnectQueryKey = [
    /**
     * To distinguish Connect query keys from other query keys, they always start with the string "connect-query".
     */
    "connect-query",
    {
        /**
         * A key for a Transport reference, created with createTransportKey().
         */
        transport?: string;
        /**
         * The name of the service, e.g. connectrpc.eliza.v1.ElizaService
         */
        serviceName: string;
        /**
         * The name of the method, e.g. Say.
         */
        methodName?: string;
        /**
         * A key for the request message, created with createMessageKey(),
         * or "skipped".
         */
        input?: Record<string, unknown> | "skipped";
        /**
         * Whether this is an infinite query, or a regular one.
         */
        cardinality?: "infinite" | "finite" | undefined;
    }
];
type KeyParams<Desc extends DescMethod | DescService> = Desc extends DescMethod ? {
    /**
     * Set `serviceName` and `methodName` in the key.
     */
    schema: Desc;
    /**
     * Set `input` in the key:
     * - If a SkipToken is provided, `input` is "skipped".
     * - If an init shape is provided, `input` is set to a message key.
     * - If omitted or undefined, `input` is not set in the key.
     */
    input?: MessageInitShape<Desc["input"]> | SkipToken | undefined;
    /**
     * Set `transport` in the key.
     */
    transport?: Transport;
    /**
     * Set `cardinality` in the key - undefined is used for filters to match both finite and infinite queries.
     */
    cardinality: "finite" | "infinite" | undefined;
    /**
     * If omit the field with this name from the key for infinite queries.
     */
    pageParamKey?: keyof MessageInitShape<Desc["input"]>;
} : {
    /**
     * Set `serviceName` in the key, and omit `methodName`.
     */
    schema: Desc;
    /**
     * Set `transport` in the key.
     */
    transport?: Transport;
    /**
     * Set `cardinality` in the key - undefined is used for filters to match both finite and infinite queries.
     */
    cardinality: "finite" | "infinite" | undefined;
};
/**
 * TanStack Query manages query caching for you based on query keys. In Connect Query, keys are structured, and can easily be created using this factory function.
 *
 * When you make a query, a unique key is automatically created from the schema, input message, and transport. For example:
 *
 * ```ts
 * import { useQuery } from "@connectrpc/connect-query";
 *
 * useQuery(ElizaService.method.say, { sentence: "hello" });
 *
 * // creates the key:
 * [
 *   "connect-query",
 *   {
 *     transport: "t1",
 *     serviceName: "connectrpc.eliza.v1.ElizaService",
 *     methodName: "Say",
 *     input: { sentence: "hello" },
 *     cardinality: "finite",
 *   }
 * ]
 * ```
 *
 * The same key can be created manually with this factory:
 *
 * ```ts
 * createConnectQueryKey({
 *   transport: myTransportReference,
 *   schema: ElizaService.method.say,
 *   input: { sentence: "hello" }
 * });
 * ```
 *
 * Note that the factory allows to create partial keys that can be used to filter queries. For example, you can create a key without a transport, any cardinality, any input message, or with a partial input message.
 *
 * @see ConnectQueryKey for information on the components of Connect-Query's keys.
 */
export declare function createConnectQueryKey<Desc extends DescMethod | DescService, Params extends KeyParams<Desc>>(params: Params): ConnectQueryKey;
export {};
//# sourceMappingURL=connect-query-key.d.ts.map